---
title: python基础概念
comments: true
copyright: true
tags:
  - python
  - 概念
categories:
  - python
abbrlink: bf330a1e
date: 2022-08-29 20:38:02
---

1, __new__和__init__的区别

__new__负责进行对象的创建,__init__负责进行对象的初始化

2,深拷贝，浅拷贝？
答：深拷贝：外围和内部元素都拷贝了对象本身，而不是引用，也就是说把对象复制一遍，对象中引用的其他对象也复制。
浅拷贝：拷贝了最外围对象本身，内部元素只是拷贝了一个引用，也就是说把对象复制一遍，该对象引用的其他对象不复制。

3, django和flask的区别?
答:
django:
①自带数据库管理app
②Python Web框架的先驱,第三方库丰富
③,上手容易开发文档详细,完善,资料丰富

flask:
①适用于做小型网站及web服务的api,开发大型网站无压力.架构需自行设计
②与关系型数据库的结构不弱于django,与非关系型数据库的结合远远强于django,

4,面向对象?
简称oop,把对象当做一个程序的基本单元,一个对象包含数据和操作数据的函数,提高了编程的效率,使其编程的重用性增高.
三大特点:
封装:把需要重用的函数或功能封装起来,方便其他程序直接调用,
继承 :子类继承父类,子类和父类拥有相同的方法和属性,子类会覆盖父类的方法和属性
多态:提高函数的健壮性和可扩展性,父类声明指向子类实现

5,如何提高Python的运行效率?
①使用生成器,节省大量内存
②针对循环优化,避免过多重复代码的执行
③核心代码用Cython,PyPy等,提高效率
④多进程,多线程,协程
⑤多个if else条件判断,可以把最有可能发生的条件放最前面写,减少程序判断次数,提高效率

6,描述数据,链表,队列,堆栈的区别?
答:数组和链表是数据存储方式的概念,数组在连续的自然空间中存储,链表在非连续的自然空间中存储
队列和堆栈是描述数据存储方式的概念,
队列是先进先出,堆栈是后进先出,堆栈和队列可以用数组表示,也可以用链表表示,
堆和栈
内存:
栈:内存小,速度快,有序,简单的数据类型放到栈里
堆:内存大,速度慢,无序,复杂的数据类型放到堆里

7,线程和进程?
线程:1,CPU进行资源分配和调度的基本单位,线程是进程的一部分,是比进程更小的能够独立运行的基本单位,一个进程下的多个线程可以共享该进程的所有资源
2,如果IO操作密集,则可以多个线程运行,效率高,缺点是如果一个线程崩溃,就会造成进程崩溃

进程:1,操作系统进行资源分配和调度的基本单位,多个进程之间相互独立
2,稳定性好,如果一个进程崩溃,不影响其他进程,但是进程消耗资源大,开启的进程数量有限

8,*args和**kw区别?
*args和**kw属于不定长参数
*args返回值为元组类型,**kw返回值为字典类型

9,=和==的区别?
=:表示赋值.将某一数值赋值 给变量
==:表示判断是否相等,返回True或者False,相等True,不相等False

TCP/UDP/HTTP/HTTPS的区别? TCP协议:是一种面向连接,可靠的,基于字节流的传输层协议,在正式通信前必须和对方建立连接,一个tcp必须经过三次对话才能建立连接,在经历4次对话结束(即三握四挥),传输可靠,速度慢,应用,传输大量数据,对可靠性要求高

UDP协议:用于www浏览的协议,特点是客户端发送的请求都需要服务器回送响应,在请求结束后会主动释放连接,从建立连接到关闭连接的过程成为"一次连接" 注: 1)在http1.0中客户端的每次请求都要求建立一次单独的连接,在处理完本次请求后就自动释放连接 2)在http1.1中,则可以在一次连接中处理多次请求,并可重叠进行,不需要等一个请求结束后再发下一个请求

HTTP/HTTPS协议 HTTP协议:超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据，互联网上应用最为广泛的一种网络协议,所有的WWW文件都必须遵守这个标准。设计HTTP的初衷是为了提供一种 发布和接收HTML页面的方法。
HTTPS协议: HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL/TLS建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。

10,可变数据类型和不可变数据类型?
可变:列表(list),字典(dict),集合(set),
不可变:整型(int),字符串(str),元组(tuple),
布尔型(bool) 

next()和iter()的区别?
我们一般通过iter()函数获取可迭代对象的迭代器,通过对获取到的迭代器不断的通过next函数 进行获取下一条数据,iter()函数 实际上就是调用了可迭代对象的__iter__方法

11,斐波那契数列
items = int(input("请输入斐波那契数列的个数:"))
fibs = [0,1]
for i in range(item - 1):
    fibs.append(fibs[-2] + fibs[-1])
print("斐波那契数列为:",fibsp[1:])

12,冒泡排序
def bubblesort(list):
    for i in range(len(lsit)):
        for j in range(len(list)-i-1):
            if list[j]>list[j+1]:
                list[j],list[j+1] = list[j+1],list[j]
    return list

if __name__ == '__main__':
    #用户输入
    str = input("请输入数字(用逗号隔开)")
    list = [int(i) for i in str.split(',')]
    print(bubblesort(list))



13, mysql索引
[mysql索引的详细说明](https://www.cnblogs.com/jiuya/p/10023483.html)
普通索引:
是最基本的索引,没有任何限制
唯一索引:
索引列的值必须唯一,但允许有空值,如果是组合索引,则列值的组合必须唯一
主键索引:
一个表只能有一个主键,不允许有空值,一般在建表的同时创建主键索引
组合索引:
指多个字段上创建的索引,只有在查询条件中使用了创建索引时的第一个字段,索引才会被使用.使用组合索引时遵循最左前缀集合
全文索引:
主要是用来查找文本中的关键字,而不是直接与索引中的值相比较.

14, 类方法,静态方法,实例方法的区别
实例方法主要用于在类中封装一个额外的功能
第一个参数必须是self,一般情况下只能用实例化对象调用,不能用类调用,如果要用类调用,需要将实例化对象传递给self.
静态方法,主要用于在类中封装一个额外的功能,创建时用@staticmethod装饰器装饰,声明为静态函数,可以用类调用也可以用实例化对象调用
类方法主要是将类作为参数传递,相当于将类当成了对象,可以调用该类中的所有方法,创建时用@classmethod装饰器装饰,声明为类函数,第一个参数必须是cls,可以用类调用也可以用实例化对象调用.

代码展示:
class A(object):
    #构造函数
    def __init__(self,title1):
        self.title = title1
        print(self.title)
    #实例函数
    def foo(self,title2):
        print(title2)
   #静态函数
    @staticmethod
    def  static_foo():
        print("静态方法")
    #类方法
    @classmethod
    def cls_foo(cls):
        cls.foo(a,'类函数调用实例函数')
        print('类方法')



15, collections库中的counter统计元素个数，

16，列表合并
a.extend(b)

17,字典合并
dic1.update(dic2)    
删除 字典
del dic['sex']

18,迭代器和生成器的区别
迭代器:for循环遍历取值的过程
生成器:用yield关键字来返回值的函数成为生成器函数

19,
del:按索引删除元素
remove:默认删除第一个元素
pop:默认删除最后一个元素或者根据索引值删除索引

20,装饰器:将函数作为参数传递,在不改变源代码的情况下扩展函数功能
def funA(fn):
    pass
@funA
def fun():
    print('a')
fun()

21,闭包:外函数包含内函数,在高阶函数之上对函数功能进行扩展,一般在装饰器下写闭包

22,set集合去重的原理
set集合去重主要是通过函数__hash__和__eq__结合实现的
①当两个变量的哈希值不相同时,就认为两个变量时不相同的
②当两个变量哈希值一样时,调用__eq__方法,当返回值为True时认为两个变量时同一个,应该去除一个,返回FALSE时,不去重

23.python中的gil锁
GIl是python的全局解释器锁,同一进程中加入有多个线程运行,一个线程在运行python程序的时候会霸占python解释器,也就是加了一把锁(GIL),使该进程内其他线程无法运行,等该线程运行完成后其他线程才能运行

24,python中的垃圾回收机制
① 引用计数机制,
②标记清除算法接触循环引用
③分代回收,以空间换时间

25,分别从前端,后端,数据库阐述web项目的性能优化

前端优化:

①,减少http请求,例如制作精灵图

②,html和CSS放在页面上部,javascript放在页面下部

后端优化:

①,缓存存储读写次数高,变化少的数据,

②,异步方式,如果有耗时操作,可采用异步,如celery

③,代码优化,避免循环和判断次数太多,如果多个if else判断,优先判断最有可能发生的情况

数据库优化:

①,如有条件,数据可以存放于redis,读取速度快,

②,建立索引,外键等

26, 常见转态码和意义

200 OK: 请求正常处理完毕

204 No Content: 请求成功处理，没有实体的主体返回

206 Partial Content: GET范围请求已成功处理

301 Moved Permanently: 永久重定向，资源已永久分配新URI

302 Found: 临时重定向，资源已临时分配新URI

303 See Other: 临时重定向，期望使用GET定向获取

304 Not Modified: 发送的附带条件请求未满足

307 Temporary Redirect: 临时重定向，POST不会变成GET

400 Bad Request: 请求报文语法错误或者参数错误

401 Unauthorized: 需要通过HTTP认证，或认证失败

403 Forbidden: 请求资源被拒绝

404 Not Found: 无法找到请求资源(服务器无理由拒绝)

500 Internal Server Error: 服务器故障或Web应用故障

503 Service Unavailable: 服务器超负载或停机维护

27, django生命周期?

从用户输入url到用户看到网页的整个过程。

1)  用户输入网址，浏览器发起请求

2)  WSGI（服务器网关接口）创建socket服务端，接受请求

3）中间件处理请求

4）url路由，根据当前请求的url找到相应的视图函数

5）进入view，进行业务处理，执行类或者函数，返回字符串

6）再次通过中间件处理相应的请求

7）WSGI返回响应

8）浏览器渲染



1,深拷贝,浅拷贝的区别?

深拷贝: 外部元素和内部元素都拷贝了对象本身,而不是引用,把对象复制一遍,对象中引用的其他对象也复制

浅拷贝:拷贝了最外围对象本身,内部元素知识拷贝了一个引用,也就是说,把对象复制一遍,该对象引用的其他对象不复制.



2,python的垃圾回收机制?

① 在python语言内部,当一个对象的引用计数是0时,它将被垃圾收集机制处理掉

② 当遇到两个对象a和b相互引用时的情况,del语句可以减少a和b的引用计数,并销毁用于底层对象的名称,需要注意的是,并不是每个对象都包含一个对其他对象的应用,所以这种情况下引用计数不会归0,对象也不会被销毁,这就是可能会导致内存泄露,所以为了解决这问题,解释器会定期执行一个循环检测器,搜索不可访问对象的循环并进行删除.



3,可变和不可变数据类型

不可变:数值型,字符串型,和元组

可变:列表和字典

不可变原因: 如果变量值发生了变化,相当于新建一个对象,而对于相同值的对象,在内存中只有一个地址

可变原因.如果对对象进行了添加,修改等操作之后,只是改变了变量的值,而不会新建一个对象,变量引用的对象的地址也不会发生变化,不过相对于相同值的不同对象,即每个对象都有自己的地址.

去重:集合去重,



4,列表切片属于浅拷贝



5,闭包

闭包:外函数包含内函数,在高阶函数之上,对函数功能进行扩展,一般在装饰器情况下写闭包.

